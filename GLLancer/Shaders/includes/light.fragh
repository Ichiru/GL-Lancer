//
// Translator library functions
//

float xlat_lib_saturate( float x) {
  return clamp( x, 0.0, 1.0);
}

vec2 xlat_lib_saturate( vec2 x) {
  return clamp( x, 0.0, 1.0);
}

vec3 xlat_lib_saturate( vec3 x) {
  return clamp( x, 0.0, 1.0);
}

vec4 xlat_lib_saturate( vec4 x) {
  return clamp( x, 0.0, 1.0);
}

mat2 xlat_lib_saturate(mat2 m) {
  return mat2( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0));
}

mat3 xlat_lib_saturate(mat3 m) {
  return mat3( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0));
}

mat4 xlat_lib_saturate(mat4 m) {
  return mat4( clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0), clamp(m[3], 0.0, 1.0));
}


//
// Structure definitions
//

struct LightSource {
    vec3 Pos;
    vec3 Rotate;
    vec4 Color;
    int Range;
    vec3 Attenuation;
};


//
// Global variable definitions
//

uniform vec4 AmbientColor;
uniform int LightCount;
uniform LightSource Lights[9];

//
// Function declarations
//

vec4 light( in vec4 ec, in vec4 dc, in vec3 position, in vec3 normal );

//
// Function definitions
//

vec4 light( in vec4 ec, in vec4 dc, in vec3 position, in vec3 normal ) {
    vec4 light;
    int i = 0;
    int dist;
    float lightAttenuation;
    vec3 lightDirection;
    float lightAngle;

    light = AmbientColor;
    for ( ; (i < LightCount); ( i++ )) {
        dist = int( distance( Lights[ i ].Pos, position) );
        if ( (Lights[ i ].Range >= dist) ){
            lightAttenuation = clamp( 0.000000, 1.00000, (1.00000 / ((Lights[ i ].Attenuation.x  + (Lights[ i ].Attenuation.y  * float( dist ))) + ((Lights[ i ].Attenuation.z  * float( dist )) * float( dist )))));
            lightDirection = normalize( (Lights[ i ].Pos - position) );
            lightAngle = max( 0.000000, dot( lightDirection, normal));
            light += ((lightAttenuation * lightAngle) * Lights[ i ].Color);
        }
    }
    return (ec + (dc * xlat_lib_saturate( light )));
}
